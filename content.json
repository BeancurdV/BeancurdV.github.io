[{"title":"","date":"2023-10-17T02:38:44.047Z","path":"2023/10/17/Frida安装与应用/","text":"一、准备工作Frida 的架构采用的是C&#x2F;S , 在PC端需要安装Client， 在设备端(手机）需要转安装Server。 1.1 下载安装Server查看Android CPU架构，并选择与之对应的Frida Server 1adb shell getprop ro.product.cpu.abi 选择 最新的frida-server-16.1.4-android-arm64.xz 进行下载。 解压frida-server,并将其上传到 /data/local/tmp 路径下。 123adb push .\\frida-server /data/local/tmpchmod 777 /data/local/tmp/frida-server-16.1.4-android-arm64./frida-server-16.1.4-android-arm64 1.2 PC端安装Frida12pip install frida-tools==16.1.4pip install frida==16.1.4 1.3 多Python环境（补充）MAC环境下Pythobn安装多版本Frida Virtualenv : 可以搭建虚拟且独立的Python环境，解决包冲突问题。 1pip install virtualenv -i http://pypi.douban.com/simple --trusted-host pypi.douban.com 1.3.1 创建虚拟环境1virtualenv -p $( which python3.7.7 ) ~/VENV/3.7.7 #创建一个虚拟的python3.7环境 1.3.2 终端环境切换至虚拟环境1source ~/VENV/3.7.7/bin/activate 1.3.3 终端环境切换至虚拟环境1deactivate 二、使用命令行 函数跟踪， 改进 Frida。 注入JS代码片或者库 到 native App？ 会有Java层App吗？ Windows, macOS, GNU&#x2F;Linux, iOS, watchOS, tvOS, Android, FreeBSD, and QNX. 场景是什么？ 加密数据API的跟踪，wireshark无能为力 命令行日志工具，比打包快 三、系统框架Native Hook JNI函数符号Hook JNI函数参数、返回值打印和替换 动态注册JNI_Onload hook RegisterNatives jnitrace 1frida -UF -l xxx.js 四、 Hook so libc 函数符号hook libc 函数参数、返回值打印和替换 主动调用libc读写文件 hook linker中的 dlopen frida-trace init_array 原理so加载执行流程 hook_linker init_array 自吐 比如 pthread_create 的hook 关键步骤： 定位目标方法所在的so 4.1 libc 函数符号123456789101112131415161718192021222324252627282930313233343536373839404142// hook pthread_create(&amp;t,NULL,detect_frida_loop,(void*)NULL);function hook_pthread()&#123; var pthread_create_addr = null; // API 参考文档 https://frida.re/docs/javascript-api/#memoryaccessmonitor var symbols = Process.findModuleByName(&quot;libc.so&quot;).enumerateExports(); // 打印symbols console.log(JSON.stringfy(symbols); // 直接根据lib.so 找pthread_create的位置 （由于一直在Android内存,所以一定存在这个地址） var pthread_create_addr = Module.findExportByName(&quot;libc.so&quot;,&quot;pthread_create&quot;); // 直接进行Attach Interceptor.attach(pthread_create_addr, &#123; onEnter:function(args)&#123; console.log(&quot;args : &quot;, args[0],args[1],args[2],args[3]); // 还可以得着so的基地址 var soBaseAddress = Module.findBaseAdress(&quot;libc.so&quot;); if(soBaseAddress != null) &#123; // 计算pthread_create地址的偏移 console.log(&quot;so base address &quot; , soBaseAddress); // 推荐《程序员自我修养》这本书 var detect_frida_loop_addr = args[2] - soBaseAddress; console.log(&quot;detect_frida_loop_addr &quot; , detect_frida_loop_addr); // 25:26s &#125; &#125;,onLeave:function(retval)&#123; console.log(&quot;return value : &quot;, retval); &#125; &#125;)&#125;setImmediate(hook_pthread)// 反调试function beginAnti()&#123; // java层执行 Java.perform(function()&#123; Java.choose(&quot;com.example.demo.MainActivity&quot;, &#123; onMatch: function(instance)&#123; console.log(&quot;found instance&quot;); instance.init(); &#125;,onComplete:function() &#123; console.log(&quot;Search Complete&quot;); &#125; &#125; &#125;)&#125; 在frida中，执行beginAnti函数即可 WebView项目位置 参考链接： Frida官网","tags":[]},{"title":"binder目录","date":"2023-10-09T10:43:46.000Z","path":"2023/10/09/binder目录/","text":"目录内容 Binder概述 Binder C测试程序体验 ServiceManager 启动 Binder Server 注册服务 Binder Client 查询服务，获得Binder Proxy对象 Binder 驱动情景分析 Binder Transaction_Stack机制 Binder Server 多线程实现 Binder C++ 程序 Binder Java程序 回顾Binder系统 Binder 死亡通知 既然有死亡通知，那是不是可以根据这个做App层的保活呢? 我们学习binder，到底学习的是什么？ 学习Binder的设计思想 了解一些驱动的知识 作为一个Android App工程师，能后看到C&#x2F;C++正确应用姿势，可以解决。 一、 Binder概述Binder 是Android系统中最主要的IPC方式。 无论是App与SystemServer中的核心服务通信，还是不同进程的服务之间通信，都离不开Binder。 因此作为Android开发者，有必要了解、熟悉Binder的通信原理。 1.1 Binder特点一言以蔽之： 简单、高效、安全。 Android系统也是使用的Linux内核，也就天然具备了 Linux中的IPC通信方式，比如：UDS (Unix Domain Socket) 、管道、消息队列和 共享内存(MemoryShare)。 N、 写在最后 补充一下IPC方式及原理 什么是操作系统管理资源，任务。管理的目的是 是一切有序、高效地进行。 管理活动，就有管理者和被管理者，就涉及到了权限。","tags":[{"name":"binder","slug":"binder","permalink":"https://beancurdv.github.io/tags/binder/"}]},{"title":"OS微内核","date":"2023-10-07T04:50:25.000Z","path":"2023/10/07/OS微内核/","text":"写操作系统到底写什么 CPU的两种运行模式：实模式、保护模式、 虚拟8086模式存在的时间短 借助BIOS中断向屏幕输出内容 你写的内核放在哪里 实模式下的内存分布 实战：手写微内核 实战：使用Bochs调试内核 NASM汇编脚本怎么写 一、人 、OS与硬件的关系 写操作系统到底写什么 显示器 主机 ​ 主板(*) ​ BIOS程序 ​ 网卡 ​ CPU(*) ​ 内存(*) ​ 显卡(*)（集成显卡、独立显卡） ​ 硬盘、软盘(*) 存储设备 ​ 需要存储内核 ​ 文件系统（没有文件系统，也可以跑起来）二期 ​ 中断：三期 ​ 键鼠 ​ U盘 无线网卡 CPU 、 中断、进程线程、网络、IO 才是重点。 写好内核程序，编译成 内核镜像 软盘是用来存储我们写的内核 把内核载入内存：BIOS例程（主板自动做的） CPU： 运行模式 权限(特权级) r0 r2 r3 CPU的段页门 (CPU权限包含这个) 内存 二、CPU两种模式实模式：实模式用的内存地址 就是物理地址。 保护模式： 虚拟地址 经过MMU 转换为 物理地址。 ​ 支持分页（1. 物理内存管理 2.分页模式） ​ 常见的分页模式： 10 - 10 - 12 ​ 2 - 9 - 9 -12 ​ 9 - 9 - 9 - 9 - 12 （linux目前的分页模式） 1MB内存条： 实模式： 可用内存小于 1MB (BIOS中断占用一部分内存，比如IDT。) 支持虚拟内存：可用大小内存 &#x3D; 1MB + 交换空间(swap) 如何判断数据是在内存，还是在磁盘上 TODO 查询磁条： **交换空间 ** Linux交换空间是多少？ ​ 如果内存占用满了，需要Kernel Killer ， 保证Linux永远不死。 CPU 的寻址能力，取决于 地址总线。在早期，地址总线就是20根 ，随后发展到 32 ， 64(只有48根在用)等。 在进入保护模式之前，所有代码都是运行在 实模式下。在实模式下，意味着什么？ 三、借助BIOS中断 输出内容 Binay&#x2F;Hex 插件 ，查看.o 文件 boot.asm 与 a.img的关系： boot.asm 就是汇编代码， a.img 系统镜像(模拟的一块软盘，内核存储在里面) ， 因为bochs、qemu都需从 硬盘、软盘中读入。 TODO zfc img 格式是什么？ 3.1 Bochs 配置与应用生成配置(bochsrc)： 1234bochs -q 4 bochsrc7 修改如下配置： 1234567display_library:x ---&gt; display_library:x,option=&quot;gui_debug&quot;floppya: type=1_44 ----&gt; floppya: image=&quot;a.img&quot;, status=inserted# 断点与调试#模数断点 xchg bx, bx ,开启模式断点magic_break: enabled = 0 ----&gt; magic_break: enabled = 1 主板的哪个部分负责加载内核？ BIOS例程： 入口 0xffff0 代码 0xfe05b CPU实模式下的寻址方式： 寄存器16位 ，地址总线是20位 在哪里 RAM 它怎么知道内核在软盘中的哪个位置？ 不固定 （X) 固定 （0磁道、0柱面、1扇区） 一个扇区是512字节 ， 就像内存 一个页4K。 结尾0x55AA，表明是内核存储位置。 第0章、第2张看一下 《真相还原》 王爽《汇编语言》 加载到哪里去？ 0x7c00 , 为什么？ 1:37min","tags":[{"name":"OS","slug":"OS","permalink":"https://beancurdv.github.io/tags/OS/"},{"name":"Kernel","slug":"Kernel","permalink":"https://beancurdv.github.io/tags/Kernel/"}]},{"title":"OS环境搭建","date":"2023-10-06T13:23:35.000Z","path":"2023/10/06/OS环境搭建/","text":"安装vmware + ubuntu虚拟机 安装bochs 2.7 安装qemu 一、安装Ubuntu虚拟机 安装VMware 安装Ubuntu虚拟机 在Ubuntu虚拟机中安装vmtools 二、安装bochs Bochs 是一个开源的虚拟机， 全模拟模式 ，因此速度慢。 优点： 调试功能强。 调试汇编、GDT、IDT、分页等。 bochs、qemu、vbox、vmware是什么？ 都是虚拟机。 实现方式：软件模拟实现； 后两者 CPU-VT技术实现 安装nasm： 1sudo apt-get install nasm 安装Bochs 依赖库 1sudo apt-get install libx11-dev libc6-dev build-essential xorg-dev libgtk2.0-dev libreadline-dev 配置 1./configure --with-x11 --with-x --enable-all-optimizations --enable-readline --enable-debugger-gui --enable-x86-debugger --enable-a20-pin --enable-fast-function-calls --enable-debugger 编译安装 12make -j4(-j后面跟CPU数，加快编译速度)sudo make install(必须root权限执行) 三、安装qemu1sudo apt-get install qemu","tags":[]},{"title":"OS概述","date":"2023-10-05T13:12:30.575Z","path":"2023/10/05/OS概述/","text":"一、手写操作系统开发环境搭建 手写OS一条龙环境 或者 手写OS自建 Windows Ubuntu16 bochs 2.7 调试汇编用的 qemu 调试C语言用的 gdb Clion tb pdd 买激活码 传送门 二、计算机行业一览![image-20231006091042602](&#x2F;Users&#x2F;zhangfengcheng&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20231006091042602.png) 正向 35岁 CURD –》 架构师（大数据、高并发），需要机会 CURD –》 技术专家 凭自己 中间件 、嵌入式 Linux内核 、 JVM工程师、音视频、Android内核优化 觉醒 逆向 https://www52pojie.cn 外挂、破解、病毒、黑客 案例：WPS 利用od 汇编代码， 还原代码 常见安全措施：加伪代码、混淆技术、加壳 应用层对抗 VS 内核层对抗 应用层调试与反调试 ， 比如gdb 内核层对抗 Hook ， tenprotect hp， 利用驱动 灰产 赚钱。 三、完整的现代操作系统结构 OS应用层： 入口、 调用内核API ​ malloc –》kmalloc OS内核层： ​ 可运行的os内核： ​ 实模式—》切换到保护模式 ​ 中断 ​ 内存 ​ 内核任务 ​ 用户态 ​ 文件系统+Shell ​ 文件系统内核 ​ 文件系统API ​ 内存错误 ​ 页换入换出 ​ 网络 ​ 多核、多线程、锁、itc、ipc 驱动 硬件 ​ 机械键盘 CPU 段页门 实模式 保护模式、虚拟8086 实模式： 16 20bit 1MB 内存 使用汇编 获取信息 中断 （硬件中断、软件中断） 编程 控制 中断控制芯片，使用 汇编 屏幕 字符模式 图形模式 存储设置 软盘 硬盘 USB 网络 网卡 输入 键盘 鼠标 四、知识准备（参考学习节奏）C语言 和 汇编 是学习底层绕不开的两个知识点，也是通往底层的第一道障碍。 学习顺序是：先C语言，后汇编，再重学C语言，做到C语言和汇编能够一一对应，也进而能理解C语言的本质。 C语言: 序员C语言基础教程 汇编： 《汇编语言》 + 汇编语言从零开始 linux编程、redis、MySql 嵌入式 Linux内核 Windows内核 等这些都需要 汇编+C语言 懂硬件原理 C++: 程序员C++语言基础教程 操作系统理论课程： 2020 南京大学 “操作系统：设计与实现” (蒋炎岩) 考研 408 必备，坚持看完两集，学不会找 up 主 五、能学到哪些知识？汇编 大约7个小时 基础、 OD(windows)调试、写内核代码（汇编脚本） 如果进度觉得慢，看《操作系统真相还原》 C语言 ​ 结合汇编去讲的 ​ 汇编、操作、内存 ​ 再往下是 硬编码、机器码（手写编程语言课程） 硬件原理 ​ 运行原理、驱动、编码实现、实战演示 任务 ​ 需要自己去实现 5.2 具体到哪些程度 内存学到这个程度： 虚拟化+内存 文件操作系统学到这个程度 头头是道，但是C语言不会写？比比皆是，不能眼高手低 64 VS 32 差异 ，寻址差异 内存差异 栈差异、 进程结构的差异。 操作系统是围绕内存展开的。 (汇编、C语言)、os融会贯通 聚集路线 ​ 单点突破 六、之后的之后 学会了操作系统，后续的路怎么走？ 正向 架构师 (实力 + 运气) 技术专家 中间件 逆向 攻 外挂 破解 调试 病毒 守 反(外挂 破解 调试 病毒)","tags":[{"name":"OS","slug":"OS","permalink":"https://beancurdv.github.io/tags/OS/"},{"name":"Kernel","slug":"Kernel","permalink":"https://beancurdv.github.io/tags/Kernel/"}]},{"title":"手写OS","date":"2023-10-05T08:40:53.171Z","path":"2023/10/05/手写OS/","text":"一、玩转CPU实模式实现操作系统微内核 汇编全貌 ， 玩转寄存器 手绘堆栈，玩转系统执行流 玩转函数，自构建执行流 玩转软、硬盘，让OS尽情发挥 二、实现真正意义上的内核深入学习CPU段机制与保护模式 编码进入保护模式，支持C语言开发与调试 玩转指针 编写屏幕驱动，实现内核打印函数printk 三、 给内核增加中断与虚拟内存管理接管BIOS中断，实现时钟中断 键盘中断 内存条检测，实现物理内存管理模块 开启分页，实现虚拟内存管理模块 带你手写协程，深入理解任务切换 四、 实现任务切换和文件系统进入用户态，手写系统调用，完成状态切换 C语言实现硬盘驱动，实现同步、异步读写硬盘 C语言实现文件系统、目录管理、文件管理","tags":[{"name":"OS","slug":"OS","permalink":"https://beancurdv.github.io/tags/OS/"},{"name":"Kernel","slug":"Kernel","permalink":"https://beancurdv.github.io/tags/Kernel/"}]},{"title":"Framework概述","date":"2023-10-05T05:46:39.000Z","path":"2023/10/05/Framework概述/","text":"一、系统启动1.1 系统启动流程1.2 Init进程1.3 Zygote进程1.4 SystemServer进程 这里包含了 系统服务启动流程 二、基础设施2.1 Handler2.2 Binder体系2.3 AMS 服务该模块要包含 App启动流程 2.3 WMS服务2.4 PKMS服务 安装过程-PKMS启动后的 APK安装过程 安装过程-单个APK安装过程 安装过程-Dex优化处理 卸载过程-单个APK卸载过程 权限管理-权限申请流程 三、子系统3.1 View体系3.2 显示系统3.2.N Android开启动画&#x2F;frameworks&#x2F;base&#x2F;cmds&#x2F;bootanimation 3.3 事件系统四、领域细分4.1 APP保活五、上下求索这里可以增加一些内核的东西。 N、AOSP中基础知识Android线程模型&#x2F;system&#x2F;core&#x2F;libutils&#x2F;Threads.h Android 智能指针 10月份 Binder 对赌； PKMS总结；事件系统；显示系统总结；handler总结","tags":[{"name":"Framework","slug":"Framework","permalink":"https://beancurdv.github.io/tags/Framework/"},{"name":"Android","slug":"Android","permalink":"https://beancurdv.github.io/tags/Android/"}]},{"title":"hexo_guide.md","date":"2023-10-05T03:19:27.000Z","path":"2023/10/05/hexo-guide-md/","text":"Hexo操作说明在public文件夹生成内容nnxxx 1hexo g // 或者 hexo generate 清空public中的内容 1hexo c // 或者 hexo clean 测试服务 1hexo s [-p 端口号] // 或者 hexo server ， 如果不指定端口号，则默认是4000 部署服务 1hexo d // 或者 hexo deploy 将编译后的 .deploy_git 文件夹，并上传到git上 创建与删除文章 123hexo new [post/draft/page] &lt;filename&gt;.md 删除source/_post文件夹下的 文档， 重新编译 hexo clean &amp;&amp; hexo g &amp;&amp; hexo s 文件布局参考链接 Hexo的常用指令合集 Hexo博客的使用","tags":[{"name":"zfc","slug":"zfc","permalink":"https://beancurdv.github.io/tags/zfc/"},{"name":"123","slug":"123","permalink":"https://beancurdv.github.io/tags/123/"}]}]